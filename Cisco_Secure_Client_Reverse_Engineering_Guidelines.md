# Рекомендации по реверс-инжинирингу Cisco Secure Client

**Введение.** Создание совместимого клиента Cisco Secure Client (AnyConnect) требует глубокого анализа оригинального программного обеспечения и его протоколов. Необходимо исследовать бинарные модули (VPN, Posture/HostScan, NVM, DART) написанные на C/C++ и понять их работу, чтобы реализовать собственную версию. Ниже приводятся рекомендации по инструментам и техникам статического и динамического анализа, а также по исследованию отдельных компонент. Отметим, что существующий open-source проект OpenConnect уже реализует большую часть VPN-протокола Cisco AnyConnect[\[1\]](https://en.wikipedia.org/wiki/OpenConnect#:~:text=It%20was%20originally%20written%20as,supported%20by%20several%20Cisco%20routers), поэтому его опыт можно использовать в качестве ориентира.

## Статический анализ (декомпиляция и дизассемблирование)

Для исследования исполняемых файлов Cisco Secure Client эффективно применять **декомпиляторы и дизассемблеры**. В вашем наборе уже есть _Ghidra 11.3_ и _Reko 0.12.0_ - они помогут получить псевдо-C код и выявить структуру программы. Ghidra обладает мощными возможностями по анализу C++ (поиск таблиц виртуальных функций, восстановление структур), а Reko может быстро делать предположения о типах. Также можно воспользоваться **IDA Pro** (если доступна) или ее бесплатным аналогом **IDA Free** для x64, либо коммерческим **Binary Ninja** - эти инструменты иногда лучше восстанавливают сложные конструкции C++. Альтернативно, **radare2** уже включён в ваш набор для быстрой навигации по дизассемблированному коду и выполнения простых патчей.

Помимо крупных средств, применяйте базовые утилиты: objdump и nm для вывода таблицы символов и секций, strings для поиска строковых констант, ldd чтобы увидеть динамические зависимости библиотеки. Например, другие исследователи AnyConnect отмечают, что они использовали _objdump_, _nm_, _ldd_ для статического анализа, а также более продвинутые инструменты наподобие **SciTools Understand**, **Kaitai Struct** (для описания бинарных структур) и даже визуализаторы байткода (binvis.io, Veles). Анализируя полученный псевдокод, старайтесь идентифицировать вызовы известных библиотек (например, OpenSSL для шифрования, Qt для GUI) - это можно сделать по строкам или по сигнатурам функций. Ghidra умеет автоматически помечать известные функции из стандартных библиотек, что поможет отсечь их и сконцентрироваться на фирменной логике Cisco.

Особое внимание уделите восстановлению **структур данных и классов C++**. Cisco Secure Client, вероятно, написан с использованием классов, поэтому вам предстоит реконструировать их из разбросанных по бинарнику таблиц виртуальных методов. Используйте возможности Ghidra (поиск по шаблону vtable или анализ слотов указателей функций) и Reko для выявления структур. Также полезно выгрузить **таблицы виртуальных методов** (VMT/VFT) - в упомянутом вами опыте реверс-инжиниринга Cisco OpenConnect эти таблицы извлекались и анализировались отдельно. Поняв иерархию классов, вам будет легче соотнести части кода с функциональными модулями (например, один класс может отвечать за сбор телеметрии NVM, другой - за VPN-соединение и т.д.).

Наконец, для статического анализа протоколов полезно изучить существующую документацию. Например, протокол AnyConnect (OpenConnect) уже описан сообществом и даже стандартизован как IETF Internet-Draft версии 1.2, что дает представление о фазах подключения (TLS-Handschake, обмен cookie/маркером WebVPN, UDP-туннель DTLS и пр.). Имея описание протокола, сравните его с тем, что видно в коде, чтобы убедиться, что вы правильно интерпретируете функции.

## Динамический анализ (отладка и трасировка)

Статический анализ следует дополнить динамическим, запустив оригинальные компоненты Cisco Secure Client в контролируемой среде (например, на виртуальной машине или в контейнере Podman, который вы подготовили). **Отладка и трассировка** помогут прояснить поведение, которое не очевидно из декомпиляции.

- **Отладчики (gdb/LLDB)**: Запустите основные процессы (например, vpnagentd - основной VPN-демон AnyConnect на Linux) под отладчиком. Это позволит ставить точки останова на ключевых функциях (по адресам из Ghidra) и наблюдать значения переменных во время работы. Особенно это полезно для C++, где можно ловить моменты создания объектов и вызовы виртуальных методов. Даже разработчики OpenConnect отмечали, что можно «поковырять троянский бинари с помощью gdb»[\[2\]](https://www.infradead.org/openconnect/csd.html#:~:text=It%27s%20also%20fairly%20easy%20to,poking%20at%20it%20with%20gdb), чтобы подглядеть его поведение - ту же тактику можно применить и к основному клиенту.
- **Трассировка системных вызовов**: С помощью strace отслеживайте системные вызовы - это покажет, к каким файлам обращается клиент, какие сетевые подключения устанавливает, какие привилегии запрашивает. Например, strace -f -e open,connect,sendto ./vpnagentd покажет загрузку конфигурационных файлов, обращение к сокетам и т.п. Аналогично, ltrace позволит увидеть вызовы библиотечных функций (например, если модуль Posture обращается к OpenSSL для шифрования, вы увидите вызовы AES_set_encrypt_key и пр.). Такой подход упоминается в опыте других инженеров, где _strace_ и _ltrace_ применялись для наблюдения за работой программ Cisco VPN.
- **Перехват сетевого трафика**: Используйте **Wireshark** или tcpdump, чтобы захватить трафик между клиентом и сервером VPN/ISE. Поскольку AnyConnect использует TLS/DTLS, расшифровать трафик напрямую не выйдет, но вы сможете увидеть общую последовательность обмена. Чтобы глубже изучить протокол, можно применить технику _man-in-the-middle_: подменить сертификат сервера (например, с помощью прокси mitmproxy) - правда, современный клиент может отказываться работать с недоверенным сертификатом. Если у вас есть доступ к серверной стороне (ASA/FTD с AnyConnect), можно включить отладочное логирование там, либо пользоваться известными **скриптами-обходчиками** (см. ниже про CSD). В крайнем случае, динамический анализ поможет достать ключи шифрования: например, вставив перехват (LD_PRELOAD библиотеку или скрипт на Frida) на функции шифрования, можно вытащить сессионные ключи TLS и расшифровать трафик для анализа.
- **Инструменты перехвата и инжектирования**: Рассмотрите использование фреймворков вроде **Frida** или **DynamoRIO** для перехвата вызовов функций на лету. Frida на Linux позволит написать скрипты на Python/JavaScript, перехватывающие, например, вызов send() или внутренних функций, формирующих отчёт posture, и логирующие их аргументы (например, получить открытый перед отправкой JSON/XML отчёт о состоянии хоста). Это мощная техника для понимания протоколов, не требующая полного понимания всего бинарника. Также, с помощью Frida вы можете модифицировать поведение - например, заставить клиент думать, что проверка HostScan прошла успешно, чтобы изучить последующий процесс.
- **Мониторинг ресурсов**: Помимо отладчиков, используйте утилиты мониторинга: htop для наблюдения за порождаемыми процессами (AnyConnect может запускать дочерние процессы для модулей DART или HostScan), netstat/ss - для мониторинга открытых портов (например, NVM-модуль может открыть локальный порт). Проверьте, не пишет ли клиент логи в систему (в Linux AnyConnect пишет в syslog или файлы в /var/log/anyconnect). Анализ этих логов тоже даст подсказки о внутренних шагах (например, сообщения об оценке posture, попытке запустить скрипт, отправке телеметрии и т.д.). В составе Cisco Secure Client есть утилита **DART** (Diagnostic AnyConnect Reporting Tool), которая собирает системную информацию и логи - вы можете запустить её и изучить собранный бандл, чтобы увидеть, какие данные клиент считает важными.

## Дополнительные техники анализа

Помимо классических статического и динамического методов, применяйте **специализированные техники**, которые позволят получить больше инсайтов:

- **Символическое выполнение и анализ путей**: Ваш набор включает фреймворк _angr_, который можно использовать для анализа критичных участков кода. Например, вы можете загрузить бинарник vpnagentd в angr и выполнить символический обход функции, отвечающей за проверку результатов posture, чтобы понять, какие условия должен удовлетворять отчёт об состоянии хоста. Хотя применение angr к большим бинарникам затруднено, его можно точечно использовать на отдельных функциях (в Ghidra можно определить адреса интересующих функций и ограничить симулируемое выполнение). Это поможет обнаружить, какие параметры влияют на решение «пускать/не пускать» VPN-клиента на основе posture, или как формируется ключ шифрования для телеметрии.
- **Сравнительный анализ разных версий (diffing)**: У вас уже подключены две версии Cisco Secure Client (например, 5.1.2.42 и 5.1.12.146). Используйте **бинарный диффинг** для выявления изменений. Инструмент _radiff2_ (в составе radare2) или плагины типа **BinDiff** (для IDA/Ghidra) позволят сопоставить функции между версиями. Это особенно полезно, если, скажем, в более новой версии был добавлен новый метод шифрования или изменён формат отчёта HostScan. Отличия в коде укажут, на что обратить внимание. Например, если в новой версии в код posture-модуля появились вызовы AES-шифрования, это явный сигнал об изменении протокола (появилось шифрование отчёта). Известно, что в сочетании с Cisco ISE некоторые данные HostScan начали передаваться в зашифрованном виде (AES-CBC) - такие изменения могли произойти между версиями[\[3\]](https://gitlab.com/openconnect/openconnect/-/issues/366#:~:text=Anyconnect%20and%20ISE%20server%20is,AES%20key%20and%20encrypt). Сравнение версий также поможет обнаружить исправление уязвимостей (по changelog можно отследить, какие CVE закрывались, и посмотреть соответствующие изменения в бинарнике, чтобы понять уязвимые места).
- **Поиск криптографических констант и алгоритмов**: Поскольку безопасность - ключевая часть VPN-клиента, ожидайте, что Cisco Secure Client использует шифрование (TLS, DTLS, AES, RSA и др.). При реверс-инжиниринге полезно идентифицировать места в коде, где происходят криптографические операции. Воспользуйтесь поиском по байтовым сигнатурам: например, константы S-Box AES или начальные значения полинома CRC - многие дизассемблеры/декомпиляторы имеют встроенные скрипты (Ghidra имеет скрипт FindCrypt, IDA Pro - плагин findcrypt) для обнаружения известных крипто-констант. Если обнаружены такие места, пометьте их и попытайтесь понять, как ключи генерируются и обмениваются. В случае AnyConnect, возможно, обнаружится логика генерации случайного ключа AES для шифрования отчёта posture, и использования RSA-ключа сервера для обмена этим ключом. Распознав это, вы сможете воспроизвести шифрование/расшифровку в своем клиенте.
- **Анализ форматов данных**: Cisco Secure Client оперирует профилями и отчетами в различных форматах (XML, JSON, бинарные blob'ы). Например, профиль NVM - это XML-файл, указывающий IP/порт коллектора и параметры сбора[\[4\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF,Anonymize)[\[5\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=,NVMProfile). Можно использовать **Kaitai Struct** или аналогичные инструменты для формального описания таких форматов и автоматического парсинга. Также, если DART-бандл представляется архивом с определённой структурой, его формат можно разобрать. Понимание форматов профилей и отчетов важно для реимплементации: ваш клиент должен генерировать корректный отчет posture и правильные записи NVM, которые сервер/коллектор примут.
- **Опора на существующие реализации**: Не стесняйтесь заглядывать в исходники OpenConnect и связанные проекты. OpenConnect уже реализует базовый VPN-протокол AnyConnect и содержит код для обхода CSD/HostScan. В официальной документации OpenConnect описано, как они поддерживают **Cisco Secure Desktop (CSD)**: по сути, либо выполняя загруженный с сервера бинарник-троян, либо подменяя его своим скриптом[\[6\]](https://www.infradead.org/openconnect/csd.html#:~:text=The%20%27Cisco%20Secure%20Desktop%27%20is,exploitable%20bugs)[\[7\]](https://www.infradead.org/openconnect/csd.html#:~:text=%2A%20%60csd,security%20concerns%20are%20greatly%20alleviated). В репозитории OpenConnect вы найдете скрипты csd-post.sh (генерирует фиктивный отчёт о системе вместо запуска трояна) и csd-wrapper.sh (скачивает и запускает trojan с минимальными привилегиями)[\[8\]](https://www.infradead.org/openconnect/csd.html#:~:text=OpenConnect%20supports%20running%20the%20CSD,argument%20with%20a%20shell%20script)[\[9\]](https://www.infradead.org/openconnect/csd.html#:~:text=server%20sent%20by%20the%20VPN,security%20concerns%20are%20greatly%20alleviated). Изучение этих скриптов и сопровождающей их документации даст понимание, какие данные ждёт от клиента сервер VPN при проверке безопасности. Аналогично, open-source проекты для обхода HostScan, такие как **hostscan-bypass**[\[7\]](https://www.infradead.org/openconnect/csd.html#:~:text=%2A%20%60csd,security%20concerns%20are%20greatly%20alleviated), могут подсказать формат отчёта: они извлекают из официальных бинарников шаблоны JSON/XML, которые нужно отослать обратно для прохождения posture-check. Используя эти наработки, вы ускорите разработку своего совместимого клиента.

## Анализ отдельных компонентов Cisco Secure Client

При реинжиниринге важно рассматривать каждый компонент Cisco Secure Client отдельно, так как у них разное предназначение и протоколы обмена. Рассмотрим основные модули и специфические рекомендации для них:

### VPN (основной VPN-протокол AnyConnect)

Основной VPN-клиент (daemon vpnagentd на Linux) отвечает за установление туннеля с VPN-шлюзом (ASA или Cisco FTD). Он выполняет TLS-соединение и аутентификацию пользователя, получает настройки маршрутов/DNS, поднимает защищенный туннель (DTLS/ESP). К счастью, этот протокол хорошо изучен сообществом: проект OpenConnect полностью реализует его и выпустил подробную спецификацию[\[1\]](https://en.wikipedia.org/wiki/OpenConnect#:~:text=It%20was%20originally%20written%20as,supported%20by%20several%20Cisco%20routers). Рекомендуется: - Сопоставить ключевые шаги подключения, описанные в документации (TLS Handshake, обмен куками веб-портала, запуск вторичного DTLS канала), с функциями в бинарнике Cisco (по строкам вроде SSL/DTLS или по вызовам библиотек GnuTLS/OpenSSL). Это подтвердит, что ваша декомпиляция верна. - Проверить, нет ли в Cisco-клиенте **дополнительных проверок**, отсутствующих в OpenConnect. Например, Cisco Secure Client может требовать установленных обновлений или определенных настроек ОС (часть _posture_), прежде чем завершить подключение. Эти проверки можно выявить, найдя в коде обращения к системным параметрам, реестру (на Windows) или файлам /sys/ /proc (на Linux). Ваша реализация должна либо выполнять аналогичные проверки, либо эмулировать "успешный" результат, иначе сервер может разорвать соединение. - В плане инструментов, VPN-модуль анализируется стандартными средствами: Wireshark с TLS-расшифровкой (если получите ключи) покажет протокол; GDB позволит проследить изменение state machine клиента (например, переход от TCP (TLS) на UDP (DTLS) после установки VPN).

### Posture (HostScan / ISE Posture Module)

Модуль Posture (раньше называвшийся HostScan или Cisco Secure Desktop) проверяет безопасность хоста перед допуском в сеть: наличие антивируса, фаервола, определенных файлов/процессов и т.д. Классически на ASA это реализовано через механизм **CSD**: сервер при подключении отправляет клиенту исполняемый модуль (т.н. _trojan_), который запускается локально и возвращает скан-отчет. Официальная документация OpenConnect указывает, что CSD - по сути небезопасный "троян", легко подделываемый[\[6\]](https://www.infradead.org/openconnect/csd.html#:~:text=The%20%27Cisco%20Secure%20Desktop%27%20is,exploitable%20bugs). Ваша задача - либо **реимплементировать функциональность HostScan**, либо _обойти_ её, убеждая сервер, что проверка пройдена.

Рекомендации для анализа Posture-модуля: - **Получите образец HostScan**: Обычно для Linux ASA-портал предлагает бинарий cscan или cstub (например, cstub.jar или ELF-бинарник) под вашу платформу. Вы можете воспользоваться OpenConnect с опцией --csd-wrapper, чтобы перехватить загрузку этого компонента. Сохранив его, проведите полный реверс-инжиниринг: какие ключи/значения он собирает (он может опрашивать ps список процессов, проверять файлы, читать /etc/\*release для версии ОС и т.д.). Статический анализ плюс динамический (запуск под strace) покажут, что именно ищет HostScan-троян. Это подскажет, какие данные должен содержать отчёт. - **Формат отчёта**: Как отмечается в OpenConnect, отчёт, который отправляет CSD-троян, представляет собой текстовый (plaintext) результат, содержащий сведения об системе[\[7\]](https://www.infradead.org/openconnect/csd.html#:~:text=%2A%20%60csd,security%20concerns%20are%20greatly%20alleviated). В более новых реализации (ISE Posture) Cisco могла добавить шифрование этого отчёта (AES-CBC). Обратите внимание на функции шифрования в модуле - возможно, отчёт шифруется перед отправкой. Если да, придётся реализовать тот же алгоритм. Сообщество OpenConnect выяснило, что AnyConnect вместе с ISE шифрует HostScan-отчет при помощи AES-CBC с заранее обговоренным ключом[\[3\]](https://gitlab.com/openconnect/openconnect/-/issues/366#:~:text=Anyconnect%20and%20ISE%20server%20is,AES%20key%20and%20encrypt). Детали можно получить, проанализировав обмен: скорее всего, сервер присылает публичный ключ или сертификат, на котором клиент шифрует данные. В процессе реверса зафиксируйте, где в коде генерируется ключ и как он применяется. - **Эмулировать или реализовать**: Для совместимого клиента вам не обязательно воспроизводить весь функционал проверки (например, реально сканировать систему на антивирус). Достаточно **эмулировать результат**, который сервер посчитает приемлемым. В этом поможет анализ трафика и существующих решений. Скрипт trojans/csd-post.sh в OpenConnect показывает пример, как сгенерировать минимальный валидный отчёт[\[7\]](https://www.infradead.org/openconnect/csd.html#:~:text=%2A%20%60csd,security%20concerns%20are%20greatly%20alleviated). Используйте его как шаблон: он содержит разделы XML/JSON с перечислением установленных программ и статусов (их можно заполнить "идеальными" значениями). Если необходимо, воспользуйтесь инструментом hostscan-bypass[\[7\]](https://www.infradead.org/openconnect/csd.html#:~:text=%2A%20%60csd,security%20concerns%20are%20greatly%20alleviated) - он способен извлечь из официального клиента правильные ID продуктов (антивирусов/фаерволов) и сформировать корректный ответ. Реверс-инжиниринг тут подскажет формат, а дальнейшие испытания на реальном сервере подтвердят, принимает ли он ваш отчет.

### Network Visibility Module (NVM)

Модуль NVM отвечает за сбор телеметрии о сетевой активности клиента. Он призван устранить "слепую зону" - когда пользователь в VPN, админы обычно не видят, куда он ходит локально. NVM собирает метаданные о соединениях (адреса, порты, протоколы, пользователь, ОС и пр.) и отправляет их на сервер сбора (например, Cisco Secure Analytics/StealthWatch или Splunk). С точки зрения реализации, NVM фактически генерирует **поток NetFlow/IPFIX** записей от клиента. В настройках AnyConnect NVM-профиля указывается адрес коллектора и порт, по умолчанию UDP 2055[\[5\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=,NVMProfile), на который шлются UDP-пакеты с flow-данными.

Рекомендации по анализу NVM: - Найдите в установке Cisco Secure Client бинарный или библиотеку, отвечающую за NVM. На Windows это сервис **acnvmagent**. На Linux возможно либо встроено в vpnagentd, либо отдельный демон. Определить можно по строкам "nvm" или по тому, что клиент открывает UDP-сокет на порт 2055 (выявляется через netstat/ss или strace). - Проведите динамический анализ: запустите VPN-сессию и сгенерируйте немного трафика через туннель (откройте несколько сайтов). Затем проверьте, отправляет ли клиент UDP пакеты на адрес коллектора. Если у вас нет реального коллектора, можно настроить локально **udpdump** на порт 2055 и увидеть содержимое пакетов. Вероятно, данные будут в формате IPFIX (Cisco называет его _nvzFlow_, расширение IPFIX)[\[10\]\[11\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=What%20if%20we%20could%20see,blog%20my%20colleague%20Justin%20wrote). Структура записей описана в документации Cisco - поля включают имя пользователя, адреса, приложений и т.д. - Статический анализ кода NVM подскажет, какие данные он собирает. Обычно NVM на клиенте перехватывает системные вызовы или использует драйвер (на Windows - драйвер TUN; на Linux, возможно, собирает из /proc/net). Если в Linux-версии нет драйвера, может использоваться библиотека libpcap или netlink для получения копий пакетов. Ищите в коде NVM references на socket, pcap или system calls как open("/proc/net",...). - Для вашей реализации NVM не обязательно досконально копировать логику сбора - можно воспользоваться готовыми библиотеками генерации NetFlow/IPFIX. Главное - воспроизвести формат сообщений, ожидаемый сервером. Из профиля NVM вы получите IP и порт, а также возможно шаблон полей. При реверсе кода Cisco попробуйте извлечь шаблон IPFIX (набор информационных элементов). Затем, в своем клиенте, вы можете с помощью, например, библиотеки _libfastnetmon_ или _PyNIC_ сгенерировать аналогичные flow records. - Учтите, что отправка данных на 2055 - UDP без подтверждения, поэтому NVM не влияет на сам VPN сеанс (если даже не отправлять данные, туннель не рвется). Однако для полноты дипломного проекта реализовать NVM полезно. Также, с академической точки зрения, вы можете описать в дипломе, как обеспечивается безопасность передачи телеметрии: обычно данные NetFlow не шифруются (рассчитаны на локальную доставку), но через VPN они уже идут в защищенном туннеле до корпоративного сервера.

### DART (Diagnostics and Reporting Tool)

DART - вспомогательный модуль, не влияющий на сессию, но собирающий информацию для отладки. По сути, DART упаковывает в архив конфигурацию, логи AnyConnect, сведения об ОС. С точки зрения реверс-инжиниринга, DART наименее критичен, так как не участвует в протоколе взаимодействия с сервером. Однако, изучив его, можно понять, **какие данные Cisco считает важными**. Рекомендуется запустить сбор DART-отчета на клиенте Cisco (есть утилита dartcli или через GUI) и затем изучить содержимое: там будут файлы с логами VPN, настройками, версиями ОС, списком запущенных процессов, настройками браузера и т.д. Это даст вам идеи, какие атрибуты системы могли бы интересовать модуль Posture.

Для реализации совместимого клиента DART можно не воспроизводить точно, но вы можете встроить в свой клиент расширенный логгинг и сбор сведений (например, ключевые строки логов: подключение успешно, ошибка posture и пр.). В контексте диплома DART не столь важен, поэтому глубоко реверсить его не обязательно - достаточно общего понимания.

## Заключение

Подводя итог, успешный реверс-инжиниринг Cisco Secure Client требует сочетания **разнообразных инструментов** и методик. Используйте мощные декомпиляторы (Ghidra, Reko, а при возможности IDA/Binary Ninja) для статического анализа кода на C/C++. Применяйте отладчики и трассировку (gdb, strace, ltrace) для наблюдения за поведением исполняемых модулей в реальном времени. Задействуйте специальные техники: символический анализ (angr) для проверки гипотез о логике, бинарный диффинг для обнаружения изменений между версиями, а также изучайте существующие open-source реализации и скрипты сообщества (OpenConnect, hostscan-bypass и др.), которые уже обходят некоторые механизмы безопасности Cisco. Не забывайте подтверждать выводы экспериментально: после каждой крупной находки (например, формат отчёта или алгоритм шифрования) тестируйте свою реимплементацию против реального сервера или в лабораторных условиях.

Следуя этим рекомендациям, вы повысите глубину анализа для своего дипломного проекта и заложите основу для разработки совместимого VPN-клиента. Такой системный подход - от разбора низкоуровневого кода до высокоуровневого протокола - обеспечит наиболее полное понимание Cisco Secure Client и приведёт к успешной реимплементации.

**Источники:**

- Arvind PJ, _Reverse Engineering CISCO OpenConnect_ - инструменты (objdump, nm, strace, binvis.io и др.) использованные при анализе VPN-клиента.
- Wikipedia: _OpenConnect_ - open-source реализация AnyConnect-протокола Cisco[\[1\]](https://en.wikipedia.org/wiki/OpenConnect#:~:text=It%20was%20originally%20written%20as,supported%20by%20several%20Cisco%20routers).
- OpenConnect Official Docs - _Cisco Secure Desktop (CSD)_: описание механизма HostScan и подход OpenConnect к его эмуляции[\[6\]](https://www.infradead.org/openconnect/csd.html#:~:text=The%20%27Cisco%20Secure%20Desktop%27%20is,exploitable%20bugs)[\[7\]](https://www.infradead.org/openconnect/csd.html#:~:text=%2A%20%60csd,security%20concerns%20are%20greatly%20alleviated).
- Plixer Blog - _How to Configure Cisco AnyConnect to Send Flow Data_: пример профиля NVM с указанием порта 2055 для коллектора (Network Visibility Module)[\[5\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=,NVMProfile).

[\[1\]](https://en.wikipedia.org/wiki/OpenConnect#:~:text=It%20was%20originally%20written%20as,supported%20by%20several%20Cisco%20routers) OpenConnect - Wikipedia

<https://en.wikipedia.org/wiki/OpenConnect>

[\[2\]](https://www.infradead.org/openconnect/csd.html#:~:text=It%27s%20also%20fairly%20easy%20to,poking%20at%20it%20with%20gdb) [\[6\]](https://www.infradead.org/openconnect/csd.html#:~:text=The%20%27Cisco%20Secure%20Desktop%27%20is,exploitable%20bugs) [\[7\]](https://www.infradead.org/openconnect/csd.html#:~:text=%2A%20%60csd,security%20concerns%20are%20greatly%20alleviated) [\[8\]](https://www.infradead.org/openconnect/csd.html#:~:text=OpenConnect%20supports%20running%20the%20CSD,argument%20with%20a%20shell%20script) [\[9\]](https://www.infradead.org/openconnect/csd.html#:~:text=server%20sent%20by%20the%20VPN,security%20concerns%20are%20greatly%20alleviated) OpenConnect VPN client.

<https://www.infradead.org/openconnect/csd.html>

[\[3\]](https://gitlab.com/openconnect/openconnect/-/issues/366#:~:text=Anyconnect%20and%20ISE%20server%20is,AES%20key%20and%20encrypt) ISE Posture support (#366) - OpenConnect - GitLab

<https://gitlab.com/openconnect/openconnect/-/issues/366>

[\[4\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF,Anonymize) [\[5\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=,NVMProfile) [\[10\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=What%20if%20we%20could%20see,blog%20my%20colleague%20Justin%20wrote) [\[11\]](https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/#:~:text=What%20if%20we%20could%20see,blog%20my%20colleague%20Justin%20wrote) How to Configure Cisco AnyConnect to Send Flow Data - Plixer

<https://www.plixer.com/blog/how-to-configure-cisco-anyconnect-to-send-flow-data/>